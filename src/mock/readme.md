##  **浏览器的渲染流程**

在讨论重绘和回流之前，先了解浏览器的渲染流程：

1. **解析 HTML** → 生成  **DOM 树**
2. **解析 CSS** → 生成  **CSSOM 树**
3. **合并 DOM + CSSOM** → 生成  **渲染树（Render Tree）**
4. **布局（Layout）** → 计算每个元素的位置和大小（也叫  **回流**）
5. **绘制（Paint）** → 将像素填充到屏幕上（也叫  **重绘**）

---

## **阶段 1：网络请求与 HTML 解析**

### **1. 下载 HTML（顺序）**

- 浏览器发起请求，下载 HTML 文件（必须按顺序，因为 HTML 是逐行解析的）。
- **阻塞点**：无（除非网络延迟）。

### **2. 解析 HTML 并构建 DOM 树（顺序 + 并行）**

- **主线程**  逐行解析 HTML，遇到外部资源时：
  - **并行加载**：浏览器通过  **预加载扫描器（Preload Scanner）**  在后台发现资源（如  `<img>`、`<script>`、`<link>`）并  **提前下载**（不阻塞主线程）。
  - **顺序阻塞**：
    - 遇到  **同步  `<script>`（无  `async/defer`）**：暂停 HTML 解析，下载并执行脚本后继续。
    - 遇到  **CSS（`<link rel="stylesheet">`）**：不阻塞 HTML 解析，但阻塞渲染（需等 CSSOM 构建完成）。

---

## **阶段 2：加载子资源（并行为主）**

### **1. 并行下载的资源**

以下资源会  **并行下载**（受浏览器并发连接数限制，通常每个域名 6~8 个）：

- **CSS 文件**（`<link rel="stylesheet">`）。
- **图片**（`<img src>`）、字体、媒体文件（`<video>`/`<audio>`）。
- **异步脚本**（`<script async>`  或  `<script defer>`）。
- **`<iframe>`  内容**（除非同域名可能复用连接）。

### **2. 顺序/阻塞的资源**

- **同步  `<script>`（无  `async/defer`）**：

  - 必须  **下载 + 执行完成**  后才能继续解析 HTML。

- **`@import`  引入的 CSS**：
  - 需先下载父 CSS 文件，再下载  `@import`  的 CSS（链式阻塞）。

---

## **阶段 3：构建 CSSOM 和渲染树（顺序）**

### **1. 构建 CSSOM 树**

- **输入**：所有 CSS 文件（内联 + 外部）。
- **行为**：
  - 解析 CSS 规则，生成  **CSSOM 树**（样式映射）。
  - **阻塞渲染**：必须等 CSSOM 构建完成，页面才能渲染（避免 FOUC）。

### **2. 合并 DOM + CSSOM → 渲染树**

- **输入**：DOM 树 + CSSOM 树。
- **行为**：
  - 过滤不可见节点（如  `display: none`）。
  - 计算每个节点的最终样式和几何属性（如宽度、位置）。
- **输出**：渲染树（Render Tree），供后续布局和绘制使用。

---

## **阶段 4：布局（Layout）和绘制（Paint）**

### **1. 布局（重排）**

- **计算元素位置和大小**：根据渲染树确定每个节点的精确坐标。
- **触发条件**：
  - 首次加载。
  - 窗口大小变化。
  - JS 修改 DOM/CSSOM（如  `element.style.width = "100px"`）。

### **2. 绘制（重绘）**

- **将像素填充到屏幕上**：根据布局结果绘制颜色、文字、边框等。
- **触发条件**：
  - 样式变化但不影响布局（如  `color: red`）。

---

## **关键总结：并行 vs. 顺序**

| **步骤**               | **并行？** | **阻塞？**                      | **优化建议**                          |
| ---------------------- | ---------- | ------------------------------- | ------------------------------------- |
| **下载 HTML**          | ❌ 顺序    | ❌ 无                           | 服务器启用 Gzip/Brotli 压缩。         |
| **下载 CSS/图片/字体** | ✅ 并行    | CSS 阻塞渲染，图片不阻塞。      | 内联关键 CSS，懒加载非首屏图片。      |
| **下载同步 JS**        | ❌ 顺序    | ✅ 阻塞解析和渲染。             | 使用  `async`  或  `defer`。          |
| **执行 JS**            | ❌ 顺序    | ✅ 阻塞（除非异步）。           | 减少同步 JS，代码拆分。               |
| **构建 CSSOM**         | ❌ 顺序    | ✅ 阻塞渲染。                   | 避免  `@import`，减少选择器复杂度。   |
| **布局/绘制**          | ❌ 顺序    | ✅ 主线程阻塞（但可分层绘制）。 | 使用  `transform`  替代  `top/left`。 |

---

## **终极优化原则**

1. **关键渲染路径（Critical Rendering Path）**：

   - 优先加载  **阻塞渲染的资源**（如首屏 CSS、同步 JS）。
   - 使用  `<link rel="preload">`  提前加载字体、关键图片。

2. **减少阻塞**：

   - JS 用  `async/defer`。
   - CSS 内联或拆分（首屏 vs. 非首屏）。

3. **并行最大化**：

   - 分散资源域名（利用 HTTP/2 多路复用）。
   - 懒加载非关键资源（如  `loading="lazy"`）。
